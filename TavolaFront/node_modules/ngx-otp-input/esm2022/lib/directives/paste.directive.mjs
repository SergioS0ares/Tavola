import { ContentChildren, Directive, EventEmitter, HostListener, Input, Output, } from '@angular/core';
import * as i0 from "@angular/core";
export class PasteDirective {
    constructor() {
        this.handlePaste = new EventEmitter();
    }
    onPaste(event) {
        event.preventDefault();
        const clipboardData = event.clipboardData?.getData('text');
        if (clipboardData && this.regexp.test(clipboardData)) {
            const values = clipboardData.split('');
            this.inputs.forEach((input, index) => {
                if (values[index]) {
                    input.nativeElement.value = values[index];
                }
            });
            this.handlePaste.emit(values);
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: PasteDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.0.1", type: PasteDirective, isStandalone: true, selector: "[ngxOtpPaste]", inputs: { regexp: "regexp" }, outputs: { handlePaste: "handlePaste" }, host: { listeners: { "paste": "onPaste($event)" } }, queries: [{ propertyName: "inputs", predicate: ["otpInputElement"], descendants: true }], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: PasteDirective, decorators: [{
            type: Directive,
            args: [{
                    standalone: true,
                    selector: '[ngxOtpPaste]',
                }]
        }], propDecorators: { inputs: [{
                type: ContentChildren,
                args: ['otpInputElement', { descendants: true }]
            }], regexp: [{
                type: Input
            }], handlePaste: [{
                type: Output
            }], onPaste: [{
                type: HostListener,
                args: ['paste', ['$event']]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFzdGUuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvbmd4LW90cC1pbnB1dC9zcmMvbGliL2RpcmVjdGl2ZXMvcGFzdGUuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDTCxlQUFlLEVBQ2YsU0FBUyxFQUVULFlBQVksRUFDWixZQUFZLEVBQ1osS0FBSyxFQUNMLE1BQU0sR0FFUCxNQUFNLGVBQWUsQ0FBQzs7QUFNdkIsTUFBTSxPQUFPLGNBQWM7SUFKM0I7UUFVWSxnQkFBVyxHQUEyQixJQUFJLFlBQVksRUFBWSxDQUFDO0tBZ0I5RTtJQWJDLE9BQU8sQ0FBQyxLQUFxQjtRQUMzQixLQUFLLENBQUMsY0FBYyxFQUFFLENBQUM7UUFDdkIsTUFBTSxhQUFhLEdBQUcsS0FBSyxDQUFDLGFBQWEsRUFBRSxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDM0QsSUFBSSxhQUFhLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLEVBQUUsQ0FBQztZQUNyRCxNQUFNLE1BQU0sR0FBRyxhQUFhLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBQ3ZDLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBRSxFQUFFO2dCQUNuQyxJQUFJLE1BQU0sQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDO29CQUNsQixLQUFLLENBQUMsYUFBYSxDQUFDLEtBQUssR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7Z0JBQzVDLENBQUM7WUFDSCxDQUFDLENBQUMsQ0FBQztZQUNILElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ2hDLENBQUM7SUFDSCxDQUFDOzhHQXJCVSxjQUFjO2tHQUFkLGNBQWM7OzJGQUFkLGNBQWM7a0JBSjFCLFNBQVM7bUJBQUM7b0JBQ1QsVUFBVSxFQUFFLElBQUk7b0JBQ2hCLFFBQVEsRUFBRSxlQUFlO2lCQUMxQjs4QkFHQyxNQUFNO3NCQURMLGVBQWU7dUJBQUMsaUJBQWlCLEVBQUUsRUFBRSxXQUFXLEVBQUUsSUFBSSxFQUFFO2dCQUdoRCxNQUFNO3NCQUFkLEtBQUs7Z0JBRUksV0FBVztzQkFBcEIsTUFBTTtnQkFHUCxPQUFPO3NCQUROLFlBQVk7dUJBQUMsT0FBTyxFQUFFLENBQUMsUUFBUSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQ29udGVudENoaWxkcmVuLFxuICBEaXJlY3RpdmUsXG4gIEVsZW1lbnRSZWYsXG4gIEV2ZW50RW1pdHRlcixcbiAgSG9zdExpc3RlbmVyLFxuICBJbnB1dCxcbiAgT3V0cHV0LFxuICBRdWVyeUxpc3QsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5ARGlyZWN0aXZlKHtcbiAgc3RhbmRhbG9uZTogdHJ1ZSxcbiAgc2VsZWN0b3I6ICdbbmd4T3RwUGFzdGVdJyxcbn0pXG5leHBvcnQgY2xhc3MgUGFzdGVEaXJlY3RpdmUge1xuICBAQ29udGVudENoaWxkcmVuKCdvdHBJbnB1dEVsZW1lbnQnLCB7IGRlc2NlbmRhbnRzOiB0cnVlIH0pXG4gIGlucHV0cyE6IFF1ZXJ5TGlzdDxFbGVtZW50UmVmPEhUTUxJbnB1dEVsZW1lbnQ+PjtcblxuICBASW5wdXQoKSByZWdleHAhOiBSZWdFeHA7XG5cbiAgQE91dHB1dCgpIGhhbmRsZVBhc3RlOiBFdmVudEVtaXR0ZXI8c3RyaW5nW10+ID0gbmV3IEV2ZW50RW1pdHRlcjxzdHJpbmdbXT4oKTtcblxuICBASG9zdExpc3RlbmVyKCdwYXN0ZScsIFsnJGV2ZW50J10pXG4gIG9uUGFzdGUoZXZlbnQ6IENsaXBib2FyZEV2ZW50KTogdm9pZCB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBjb25zdCBjbGlwYm9hcmREYXRhID0gZXZlbnQuY2xpcGJvYXJkRGF0YT8uZ2V0RGF0YSgndGV4dCcpO1xuICAgIGlmIChjbGlwYm9hcmREYXRhICYmIHRoaXMucmVnZXhwLnRlc3QoY2xpcGJvYXJkRGF0YSkpIHtcbiAgICAgIGNvbnN0IHZhbHVlcyA9IGNsaXBib2FyZERhdGEuc3BsaXQoJycpO1xuICAgICAgdGhpcy5pbnB1dHMuZm9yRWFjaCgoaW5wdXQsIGluZGV4KSA9PiB7XG4gICAgICAgIGlmICh2YWx1ZXNbaW5kZXhdKSB7XG4gICAgICAgICAgaW5wdXQubmF0aXZlRWxlbWVudC52YWx1ZSA9IHZhbHVlc1tpbmRleF07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5oYW5kbGVQYXN0ZS5lbWl0KHZhbHVlcyk7XG4gICAgfVxuICB9XG59XG4iXX0=